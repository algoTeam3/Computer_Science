### 인증 방식 종류 (Cookie & Session & Token)

- 서버가 클라이언트 인증을 확인하는 방식은 대표적으로 쿠키, 세션, 토큰 3가지 방식

### 1. Cookie 인증

```
key-value 형식의 문자열.
클라이언트가 웹사이트에 방문할 경우, 그 사이트가 사용하는 서버를 통해 클라이언트 브라우저에 설치되는 작은 기록 정보 파일
각 사용자마다 브라우저에 정보를 저장하니 고유 정보 식별이 가능하다.
```

#### ✔️ 사용 방식

<img src="https://user-images.githubusercontent.com/60870438/184661339-27f30c82-e9b2-4fef-94a8-9dfac4c03907.png" width=70%>

1. 클라이언트가 서버에 접속 요청
2. 서버는 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더 Set-Cookie에 담는다.
3. 이후 클라이언트의 요청마다 매번 저장된 쿠키를 요청 헤더의 Cookie에 담아 보냄. 
  서버는 쿠키에 담긴 정보를 바탕으로 해당 요청 클라이언트가 누군지 식별한다.
  
#### ✔️ 단점

- 보안에 취약. 쿠키 값을 그대로 보내기 때문
- 쿠키의 용량 제한
- 웹 브라우저마다 쿠키 지원 형태가 다름. 브라우저간 공유 불가능
- 쿠키 사이즈가 커질 수록 네트워크 부하 심함

-----

### 2. Session 인증

```
쿠키 보안적 이슈를 막기위해 세션은 민감 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리
서버의 메모리에 저장하거나 로컬 파일 혹은 DB에 저장
```

#### ✔️ 세션의 모습

<img src="https://user-images.githubusercontent.com/60870438/184662434-dff1bac6-8daa-4072-b7f4-1c21a2e14a44.png" width=30%>

- key에 해당하는 session ID와 이에 대응하는 value로 구성.
- value에는 세션 생성 시간, 마지막 접근시간 등 저장한 속성이 Map 형태로 저장

#### ✔️ 사용 방식

<img src="https://user-images.githubusercontent.com/60870438/184662673-350ca8c6-952f-4cef-a09d-7f0428a999a8.png" width=30%>

1. 웹사이트에 로그인하면 세션이 서버 메모리(DB)에 저장. 세션 식별을 위해서 Session id 기준을 정보 저장
2. 서버에서 브라우저의 쿠키에 session id 저장
3. 쿠키에 정보가 담겨 있기 때문에 브라우저는 해당 사이트에 대한 모든 요청에 Session id를 쿠키에 담아 전송
4. 서버는 요청에 Session id와 서버 메모리로 관리하는 Session id를 비교하며 인증 수행

#### ✔️ 단점

- 쿠키를 포함한 요청이 외부에 노출되어도 session id는 민감 정보를 담고있지 않다.
- 그러나 session id를 탈취해 클라이언트인척 위장의 보안 문제가 생김.
- 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버 부하 심함

-----

### 3. Token 인증

```
클라이언트가 서버에 접속하면 서버에서 해당 클라이언트에게 인증의 의미로 토큰 부여.
토큰은 유일하며 클라이언트는 요청시 요청 헤더에 토큰 저장.
요청으로 받은 토큰과 서버에서 제공한 토큰의 일치 여부를 체크해 인증
```

#### ✔️ 특징

- 토큰은 서버가 아닌 클라이언트에 저장되기 때문에 세션 과정에서 서버의 부담이 줄어듬
- 토큰 자체에 데이터가 들어있어 클라이언트에서 받아 위조 판별
- 서버(세션) vs 토큰
  - 세션: 사용자의 인증 정보를 서버에서 관리함으로 요청을 받으면 클라이언트의 상태를 유지해야한다. stateful 이는 사용자가 증가하면 성능의 문제를 일으킬 수 있고
    확장성이 어려움
  - 토큰: 인증받은 사용자에게 토큰을 발급해, 로그인이 필요한 작업의 경우, 헤더에 토큰을 보내 인증받은 사용자인지 확인.
    상태 유지가 필요없으며 stateless

#### ✔️ 사용 방식

<img src="https://user-images.githubusercontent.com/60870438/184664859-1b70d038-a085-4999-a56c-e35fd48a63e6.png" width=30%>

1. 사용자 로그인
2. 서버가 클라이언트에게 유일한 토큰 발급
3. 클라이언트는 토큰을 쿠키나 스토리지에 저장하고 요청이 생길 때마다 HTTP 요청 헤더에 토큰 저장
4. 서버는 전달받은 토큰 검증 후 요청에 응답.
  토큰에 요청한 사람의 정보가 담겨있어 DB 조회없이 누가 요청하는지 알 수 있음

#### ✔️ 단점

- 쿠키/세션과 다르게 토큰 자체의 데이터 길이가 김. 인증 요청이 많아지면 네트워크 부하 심함
- 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.
- 탈취당하면 대처가 어렵다. (사용기간에 제한을 둔다)

------

# JWT(Json Web Token)

```
인증에 필요한 정보들을 암호화시킨 JSON 토큰
JWT 기반 인증은 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식.
```
#### ✔️ 특징

- JSON 데이터를 Base64 URL-safe Encode 방식을 통해 인코딩해 직렬화.
- 토큰 내부에 위변조 방지를 위해 개인키를 통한 전자서명도 들어있음

#### ✔️ JWT 구조

<img src="https://user-images.githubusercontent.com/60870438/184669196-11f20a19-63a5-4c99-bd30-51f56429ebd3.png" width=70%>

- header에는 사용할 타입과 해시 알고리즘의 종류가 담겨있다.
- payload는 서버에서 첨부한 사용자 권한 정보와 데이터. JWT를 통해 알 수 있는 데이터
- signature은 header와 payload를 인코딩후 해시 함수 적용, 개인키로 서명한 전자서명이 담겨있다. 위변조 방지
- 전자서명은 비대칭 암호화 방식을 사용한다.

#### ✔️ 인증 방식

<img src="https://user-images.githubusercontent.com/60870438/184669782-9deca76d-bd2f-4f6e-aa98-c1b20bcac49a.png" width=50%>

1. 사용자가 로그인 인증 요청
2. 서버는 요청의 header, payload, signature를 정의하고 이를 한번 더 암호화해 jwt를 생성. 쿠키에 담아 클라이언트에게 발급.
3. 클라이언트는 응답받은 JWT를 로컬 스토리지 저장. 서버에게 요청시 Authorization header에 Access Token을 담아 보냄
4. 헤더에 담긴 JWT의 인증. 인증시 payload에 들어있는 유저의 정보를 select해 클라이언트에게 전달
5. 요청시 토큰 시간이 만료되면 클라이언트는 refresh 토큰을 이용해 
6. 새로운 토큰 재발급

```
JWT의 목적
토큰 안에 들어있는 정보가 무엇인지 아는 것이 아니라 해당 토큰이 유효한지 판단하는 것이 중요!
클라이언트로부터 받은 JWT 토큰의 헤터, 페이로드를 사용해 서버의 key값을 이용해 시그니처를 만들고 이를 JWT의 시그니처와 비교해 인증을 시도한다.

정보보호가 아닌 위조방지(식별)의 목적
```

#### ✔️ 장점

- 데이터의 위변조 분별
- 별도의 저장소 X
- 클라이언트의 인증 정보를 저장하는 세션과 다르게 stateless
- 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유 가능
- 앱에서 사용 가능
- DB 조회가 없다.

#### ✔️ 단점

- JWT의 길이가 길어 네트워크 부하
- payload 자체는 암호화되지 않아 민감 정보는 담을 수 없다.
- 토큰 탈취시 만료까지 대처가 어렵다.


# 참고

- [JWT 토큰 인증 이란?](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)
- [JWT 알아가기](https://brunch.co.kr/@jinyoungchoi95/1)
